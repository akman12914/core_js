## 문자형

    const double = "hello" : //string literal - string 이지만 객체
    const str = new String('hello') : //string constructor function -object - 생성자 함수. 가장 큰 특징 : 앞을 대문자로 시작하는 파스칼케이스 기법을 사용 (String)

모든 문자열은 객체가 문자를 생성하는형태.
왜 double도 객체인가? > 'hello'. toUpperCase()로 함수를 불러 수행하는 것이 가능하다. 그것은 원래 'hello'가 객체였기 때문이다

## 숫자형

    const integer = 150; //number literal - number. 하지만 결국 객체를 부모로 한다.
    const num = new Number(23); //number constructor function

### bigint

생성자함수 사용 불가

symbol
생성자 함수 사용 불가

boolean
생성자 함수 사용 가능

## 객체

const obj = new Object();
생성자 함수 사용 가능

객체에 메서드를 정의하는 방법

```js
const user = {
  name: "tiger",
  age: 42,
  sayHi: function () {}, //1. normal function
  sayHi2: () => {}, //2. arrow function
  sayHi3() {}, //3. concise method 축약된 메서드
};
```

객체 안에 설정된 함수는 메서드라는 이름을 가진다.
메서드 외의 key/value쌍을 프로퍼티라고 부른다.

```
console.dir
구성요소를 확인할 수 있다.

    console.dir(user.sayHi)

    > prototype :
      constructor

    console.dir(user.sayHi2)

    > prototype - constructor이 없음

    console.dir(user.sayHi3)

    > prototype - constructor이 없음
```

### arrow와 concise의 차이

this : 나를 호출한 대상

user.sayHi() _normal_

> this : sayHi 내 this

user.sayHi2()

> this : 전역 _arrow_

    this를 바인딩하지 않는다.(상위 컨텍스트에서 this를 찾는다.)
    화살표 함수는 new와 함께 실행할 수 없습니다.
    this가 없기 때문에 화살표 함수는 생성자 함수로 사용할 수 없다는 제약이 있습니다. 화살표 함수는 new와 함께 호출할 수 없습니다.

user.sayHi3()

> this : sayHi 내 this _concise_

```js
const user = {
  name: "tiger",
  age: 42,
  sayHi: function () {}, //1. normal function
  sayHi2: () => {}, //2. arrow function
  sayHi3() {
    function sayBye() {
      console.log((this.age = 30));
      //전역 상위컨텍스트인 this에 적용됨

    sayBye();

    const sayBye = () => {
      console.log((this.age = 30));
    };
    //올바르게 user의 정보가 나옴
  }, //3. concise method 축약된 메서드
};
```

sayHi3의 this는 호출대상인 userd이다.
그런데 sayBye의 this는 user이 아니라 전역 상위컨텍스트가 this로 나타난다. 어째서인가?

> sayBye는 window.sayBye. 정확히 윈도우가 호출한거다.

> 해결 : 화살표 함수로 상위 컨텍스트 (user)의 this를 가리킨다.

- 객체의 메서드를 정의할 때 => concise method

- 메서드 안에서 함수를 정의해야할 때 => arrow fuction 사용 권장 - 상위 컨텍스트 this를 찾기 위해

function A(){

}

a()
이건 생성자 없는 함수 호출할 때
new A()
이건 생성자 있는 함수 호출할때 > 구분하려고 보통 파스칼(앞문자가 대문자)

남의 코드를 사용할 때 constructor가 있는 함수를 구분해야겠죠?

어떨 때 constructor가 필요할까요
-> 지속적으로 반복되는 객체를 여러번 찍어낼 때

### class User{}

이게 생성자 함수의 명시적 문법이었음!!!

### 함수

function sum (a,b)
전달받을 매개변수

sum(a,b)
전달해주는 argument

> 화살표 함수는 일반 함수와는 다르게 모든 인수에 접근할 수 있게 해주는 유사 배열 객체 arguments를 지원하지 않습니다.

null - 객체가 아님(그러나 문법상 오류로 객체로 나옴)

`이게 {&변수}`
interpolation > {&} :안에 표현식
백틱: 템플릿 리터럴

연산자/연산식 - 값 반환

object 아래 String Number 등 자료형은 부모를 바꿔치기 할 수 있다네;
이 자료형들은 Prototype이라는 조상이 있고, 이 조상들은 객체와 일치하게 된다.
->종착지는 object
